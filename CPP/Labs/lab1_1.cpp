/*
	В результате выполнения данной работы слушатель получает много мелких но необходимых
	для дальнейшей работы навыков, поэтому задание построено как последовательность 
	закомментированных блоков, которые требуется последовательно раскомментировать, 
	отвечая  при этом на поставленные вопросы.

	Примерная последовательность действий при отладке проекта:
	1. наберите (исправьте, раскомментируйте нужный фрагмент) исходный текст программы;
	2. откомпилируйте (Build/Compile  ***.cpp или Ctrl+F7)
		Замечание: этот этап явно вызывать необязательно, но полезно для начинающего 
			программиста, т.к. позволяет увидеть ошибки (errors) и предупреждения
			(warnings), возникающие при компиляции данного конкретного файла;
	3. скомпонуйте проект(Build/Build ***.exe или F7)
		Замечание 1: этот этап тоже необязателен, но настоятельно рекомендуем, т.к. 
			позволяет перекомпилировать только измененные файлы и в случае отсутствия
			ошибок всегда полезно посмотреть на выдаваемые компилятором замечания;
		Замечание 2: перед тем, как строить проект, неплохо убедиться  в том, что 
			исполняемый код будет содержать информацию для отладчика - 
				(Build/Configuration Manager.../Configuration - Debug - тип сборки проекта);
	4. поставьте на интересующих Вас строках исходного кода остановы(breakpoints) - F9 или 
		просто кликните левой кнопкой на левой серой полосе окна редактирования; 
	5. запустите программу в режиме отладки 
		(Debug/Start... или  F5);

  Замечание: для перечисленных выше действий приведены комбинации клавиш и соответствующие 
		пункты меню, однако во многих случаях гораздо быстрее то же самое можно сделать с 
		помощью кнопок на Tool Bar, в чем слушатель может преуспеть самостоятельно.

*/

#include  <iostream>		//для использования потоков ввода/вывода

int nTwin=1;			//глобальная переменная
namespace TwinSpace{ int nTwin=2;}	//переменная объявлена в
						//пространстве имен - TwinSpace

#define	  stop __asm nop	//с помощью макроподстановки задаем "пустую" команду.
							//Эта макроподстановка нужна только для того, чтобы
							//можно было поставить на этой строке точку останова.

int main()
{

 //**********************************************************
	//Задание 1. Работа с отладчиком. Базовые типы данных. Выполняя программу по шагам, 
	//следите за значениями переменных и интерпретируйте результат (помните, что 
	//количество байтов, отводимых под int, системо-зависимо).
	//Обратите внимание на разную интерпретацию отладчиком signed и unsigned целых типов 
	//данных, а также на внутреннее представление отрицательных целых чисел.

	
	char cByte = 'A';
	cByte    = 0x42; 
	cByte    = 66;  
	cByte    = -1;   

	unsigned char ucByte = 0x41; 
	ucByte   = 'B';
	ucByte   =	-1; 

	int iInt =  0xffffffff; 

	unsigned int uiInt = 0xffffffff; 

	float fFloat = 1.f;  
	double dDouble = 1.; 

	// Выполните фрагмент, приведенный далее. В комментариях отразите,
	// что реально заносится в переменную. Объясните разницу между этим 
	// значением и инициализатором.

	double d = 0.1234567890123456789123456789; 
	float  f = 0.1234567890123456789123456789; 

	d	=	1.; 
	d	=	0.999999999999999999999999999999999; 

	stop
	
	// В комментариях напишите результат, возвращаемый оператором sizeof для
	// переменной типа wchar_t (ее размер)
	wchar_t cw = L'Ф';//
	size_t n = sizeof(cw); //

	stop


// **************************************************************
	//Задание 2a. Неявное приведение типов данных.
	//Объясните разницу результата при выполнении (1) и (2):
	//Покажите явно (напишите в коде) преобразования, которые неявно выполняет компилятор

	iInt=1;
	double dDouble1=iInt/3;		// (1)
	double dDouble2=iInt/3.;	// (2)


	// Ассоциативность операторов.
	// Синтаксис языка C допускает "цепочечное" присваивание
	// (как в строках (1) и (2)). Посмотрев результаты выполнения строк (1) и (2)
	// (значения переменных dDouble, fFloat, nInt, sShort, cByte), определите порядок 
	// выполения присваиваний при цепочечной записи и объясните результат.
	// Расставте скобки, явно определяющие порядок выполнения, как это сделал бы компилятор.
	// Объясните (в комментариях) предупреждения (warnings) компилятора.

	short sShort;
	dDouble=fFloat=iInt=sShort=cByte=3.3/3;			// (1)
	
	cByte=sShort=iInt=fFloat=dDouble=3.3/3;			// (2)

	// ниже Вам дан пример "небрежного" использования неявного приведения типов, что может 
	// привести к нежелательным результатам - объясните (в комментариях), к каким?
	// Напишите явно преобразования, которые неявно выполняет компилятор

	iInt	=	257;
	cByte	=	iInt; //

	unsigned char cN1=255, cN2=2, cSum;
	cSum = cN1 + cN2; //

	//Сравните предыдущую строчку с приведенной ниже. Объясните (в комментариях),
	//почему в следующей строке не происходит выход за разрядную сетку
	// Напишите явно преобразования, которые неявно выполняет компилятор
	int iSum = cN1+cN2; //

	//Напишите, почему при сложении одинаковых значений (одинаковых в двоичной системе) 
	// в строках (1) и (2) получаются разные результаты
	// Напишите явно преобразования, которые неявно выполняет компилятор и объясните,
	// что при этом происходит
	char c1=0xff, c2=2;
	unsigned char uc1=0xff, uc2=2;
	int iSum1= c1 + c2;   //(1)
	int iSum2= uc1 + uc2; //(2)

	stop

	
// ***********************************************************
	//Задание 2b. Явное приведение типов данных.
	//Проинтерпретируйте результат (значения переменной dDouble) в строке (3)
	// Напишите явно преобразования, которые неявно выполняет компилятор
	int nTmp=100, nn=3;
	dDouble=3.3 + nTmp / nn; // (3)

	//Получите результат без потери точности с помощью оператора явного
	//приведения типа

	//double dDouble3=...
		


	stop



	return 0;//код завершения приложения
}	// Конец функции main()

